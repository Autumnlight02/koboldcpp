import createClient from 'openapi-fetch';
import type { components, paths } from './generated/koboldCppDefinition'; // generated by openapi-typescript
import fs from 'fs';
const textDecoder = new TextDecoder();
import Eventsource from 'eventsource';
import { chain } from 'stream-chain';
import { parser } from 'stream-json';
import { pick } from 'stream-json/filters/Pick';
import { ignore } from 'stream-json/filters/Ignore';
import { streamValues } from 'stream-json/streamers/StreamValues';
import { streamArray } from 'stream-json/streamers/StreamArray';
import { streamObject } from 'stream-json/streamers/StreamObject';

import { Readable } from 'stream';
import { ReadableStream } from 'stream/web';

export default class KoboldCpp {
	direct: ReturnType<typeof createClient<paths>>;
	#baseUrl: string;
	get baseUrl() {
		return this.#baseUrl;
	}
	constructor(args: { baseUrl: string }) {
		this.#baseUrl = args.baseUrl;
		this.direct = createClient<paths>({ baseUrl: args.baseUrl });
	}

	async getMaxContextLength() {
		return this.direct
			.GET('/api/v1/config/max_context_length')
			.then((e) => e.data?.value);
	}
	async getMaxLength() {
		return this.direct
			.GET('/api/v1/config/max_length')
			.then((e) => e.data?.value);
	}
	async getTrueMaxLength() {
		return this.direct
			.GET('/api/extra/true_max_context_length')
			.then((e) => e.data?.value);
	}
	async getSimplifiedVersion() {
		return this.direct
			.GET('/api/v1/info/version')
			.then((e) => e.data?.result as string | undefined);
	}
	async getVersion() {
		return this.direct.GET('/api/extra/version').then((e) => e.data);
	}
	async getModel() {
		return this.direct
			.GET('/api/v1/model')
			.then((e) => e.data?.result as string | undefined);
	}
	async getPerf() {
		return this.direct.GET('/api/extra/perf').then((e) => e.data);
	}
	async generateStream(arg: {
		body: components['schemas']['GenerationInput'];
	}) {
		// return fetch(this.baseUrl + '/api/extra/generate/stream', {
		// 	method: 'POST',
		// 	body: JSON.stringify(arg),
		// });
		return this.direct
			.POST('/api/extra/generate/stream', {
				body: arg.body,
				parseAs: 'stream',
			})
			.then(async (res) => {
				const reader = res.response.body!.getReader();

				// const stream = new Readable();
				// const getter = chain([
				// 	res.response.body as any,
				// 	parser(),
				// 	streamValues(),
				// 	// streamArray(),
				// ]);
				// getter.on('data', (data) => {
				// 	// ...
				// 	console.log('data');
				// });
				// getter.on('end', () => {
				// 	console.log('ennd');
				// 	// ...
				// });
				// getter.on('error', (err: Error) =>
				// 	console.error('stream failed:', err)
				// );

				while (true) {
					const { done, value: valueBuffer } =
						(await reader.read()) as {
							done: Boolean;
							value: Uint8Array;
						};
					if (done) {
						// Do something with last chunk of data then exit reader
						return;
					}
					let res: any[] = [];
					for (let i = 0; i < valueBuffer.length; i++) {
						const arr = new Uint8Array(1);
						arr.set([valueBuffer[i]], 0);
						res.push([valueBuffer[i], textDecoder.decode(arr)]);
					}
					console.log(textDecoder.decode(valueBuffer));
					console.log(res);
					// console.log('-- chunk console log: --           ');
					// console.log(res);
					const eventTypeStartInded = 7; // at :
					const eventTypeEndIndex = valueBuffer.indexOf(
						10,
						eventTypeStartInded
					); // find \n
					const eventTypeBuffer = valueBuffer.slice(
						eventTypeStartInded,
						eventTypeEndIndex
					);
					const eventType = textDecoder.decode(eventTypeBuffer);
					// " " (space) is 32
					//Jump over data: text directly to json start
					const dataStart = eventTypeEndIndex + 7;
					const dataEnd = valueBuffer.length;
					const dataBuffer = valueBuffer.slice(dataStart, dataEnd);
					const dataString = textDecoder.decode(dataBuffer);
					// const eventType = string.slice(
					// 	startEventType,
					// 	endEventType
					// );
					// console.log(dataString);
					// stream.push(dataString);
					// const result = {
					// 	eventType: eventType,
					// };
					// Otherwise do something here to process current chunk
				}
			});
	}
}

//Skipped ones
/*

*/

// function webReadableStreamToNodeReadable(
// 	webStream: WebReadableStream
// ): Readable {
// 	return Readable.fromWeb(webStream);
// }

// // Usage
// const response = await fetch(url);
// const reader = response.body!.getReader();
// const webReadableStream = new WebReadableStream(reader);
// const nodeReadableStream = webReadableStreamToNodeReadable(webReadableStream);
